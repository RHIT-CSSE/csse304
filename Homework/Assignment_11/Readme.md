## Assignment 11

**You must work with your Interpreter project partner for A11.  One partner should submit the assignment to the Gradescope server. Make sure to add your partner in Gradescope as you submit.**

No mutation is allowed in your code.

## Warm-up - bintree-add (10 points)

This is just a little problem to remind you about define-datatype.

The given code includes a datatype for bintree.  Write a function
bintree-add that takes a bintree and a number and returns a new
bintree where all the leaves have that number added.

So adding 3 to bintree (interior-node (leaf-node 0) (interior-node (leaf-node 10) (leaf-node 100)))
produces (interior-node (leaf-node 3) (interior-node (leaf-node 13) (leaf-node 103)))

## Parsing Scheme (85 Points)

**HW11 is a with-your-team assignment.  You should not begin it until teams are established.**

The given code has a bare-bones parser for the lambda calculus plus numbers.  Your goal will be to expand parse/unparse to accommodante something much closer to a full subset of scheme.  You’ll want to do that step by step, testing each individual construct by hand.  I have a suggested order here.

- Modify the expression datatype, parse-exp, and unparse-exp so that they work for lambdas with multiple parameters and procedure applications with multiple parameters (including 0 parameters).
- Add basic let, name let, let*, and letrec.  Exactly how you want your abstract syntax trees to handle these multiple similar structures is up to you – the only requirement at this point is that you be able to unpase them correctly.  Many ways will work – just try to avoid code duplication and realize that you might want to change your mind later in the interepreter.
- Allow multiple bodies for lambda, let (including named let), let*,
  and letrec expressions. Also allow (lambda x lambda-body …) (note
  that the x is not in parentheses).  You are NOT required to handle
  lambdas that take several normal arguments and 1 catch all
  i.e. (lambda (a b . c) ...) is NOT something you must handle.
- Add if expressions, with and without the "else" expression;
- Add set! expressions.  
- Expand lit-exp, which currently only supports number but will be the parsed form for numbers, strings, quoted lists, symbols, the two Boolean constants #t and #f, and any other expression that evaluates to itself.   Then make parse-exp recognize these literals. 
- Make parse-exp bulletproof. I.e., add error checking to your parse-exp procedure. It should "do the right thing" when given any Scheme data as its argument. Error messages should be as specific as possible (that will help you tremendously when you write your interpreter in a later assignment). Call the error procedure (same syntax as Chez Scheme's errorf, whose documentation can be found at http://www.scheme.com/csug8/system.html#./system:s2) ; the first argument that you give to error for this problem must be 'parse-exp. This will enable the grading program to process your error message properly, i.e. to recognize that the error is caught and the error message is generated by your program rather than by a built-in procedure. 
- Modify unparse-exp so it accepts any valid expression object produced by parse-exp, and returns the original concrete syntax expression that produced that parsed expression.   Suggestion:  when you modify or add a case to parse-exp, go ahead and make the corresponding change to unparse-exp and test both.  No credit for this part unless your unparsed-exp is representation-independent (using cases instead of car, cadr, etc.)

*The grading program will have two kinds of tests for this problem:*

1. Call parse-exp with an argument that is not a valid expression, then check to make sure that your program uses (error 'parse-exp …)to flag the input as an error.

2. Call (unparse-exp (parse-exp x)), where x is a valid expression, and check to see if your  code returns something that is equal? to the original expression. I will never directly compare the output of your parse-exp to any particular answer, since you have some leeway in what your parsed expressions look like. Note: It is possible to "pass" these tests by simply defining both procedures to be the identity procedure, so that you do not parse at all. This is clearly unacceptable.
